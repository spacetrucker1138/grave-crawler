<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Grave Crawler</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      background: #0a0a0a url('assets/title.jpg') center center / cover no-repeat fixed;
      background-attachment: fixed;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      min-height:100vh; overflow:hidden;
      font-family:'Courier New', monospace;
    }
    #wrapper { display:flex; flex-direction:column; align-items:center; gap:8px; }
    #hud {
      display:flex; gap:20px; align-items:center;
      color:#f0d070; font-size:15px; letter-spacing:2px;
      text-shadow:0 0 10px #c8a84bcc, 0 1px 3px #000;
      padding:8px 20px;
      background:rgba(0,0,0,0.72);
      border:1px solid rgba(200,168,75,0.35);
      border-radius:8px;
      box-shadow:0 2px 12px #000a;
      margin-bottom:6px;
    }
    #spell-bar { display:flex; gap:8px; align-items:center; }
    .spell-slot {
      width:38px; height:38px; border:2px solid #444;
      border-radius:4px; display:flex; align-items:center; justify-content:center;
      font-size:18px; cursor:pointer; background:#111; position:relative;
      transition:border-color .15s, background .15s;
      user-select:none;
    }
    .spell-slot.ready  { border-color:#f0d070; box-shadow:0 0 12px #c8a84b88; }
    .spell-slot.active { border-color:#fff; background:#1a1a2a; }
    .spell-slot.not-ready { opacity:0.4; }
    .spell-label {
      position:absolute; bottom:-20px; left:50%; transform:translateX(-50%);
      font-size:9px; color:#b8955a; white-space:nowrap; letter-spacing:1px;
      text-shadow:0 1px 3px #000;
      font-weight:bold;
    }
    canvas {
      display:block;
      image-rendering:pixelated; image-rendering:crisp-edges;
      border:2px solid #2a1a0a;
      box-shadow:0 0 60px #000000cc, 0 0 20px #1a0a0088;
    }
    #effect-hud { color:#f0d070; font-size:13px; font-weight:bold; min-width:140px; text-align:center; text-shadow:0 0 8px #c8a84bcc, 0 1px 3px #000; letter-spacing:1px; }
    #overlay {
      position:fixed; inset:0; background:#000000dd;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      z-index:10; color:#c8a84b;
      font-family:'Courier New',monospace;
    }
    #overlay h1 {
      font-size:52px; letter-spacing:10px; text-shadow:0 0 30px #c8a84b, 0 0 60px #c8a84b44;
      margin-bottom:8px; font-weight:900;
    }
    #overlay h2 { font-size:18px; color:#777; letter-spacing:4px; margin-bottom:36px; }
    #overlay p  { color:#999; font-size:13px; letter-spacing:1px; margin:3px 0; }
    .spell-hint { color:#c8a84b66; font-size:11px; margin-top:10px; }
    #start-btn {
      margin-top:36px; padding:14px 56px; background:transparent;
      border:2px solid #c8a84b; color:#c8a84b; font-size:18px;
      letter-spacing:6px; cursor:pointer; font-family:inherit;
      text-transform:uppercase; transition:all .2s;
    }
    #start-btn:hover { background:#c8a84b22; box-shadow:0 0 24px #c8a84b88; }
    #score-big { font-size:42px; margin:10px 0; }
    #game-over-msg { font-size:30px; color:#cc3333; letter-spacing:6px; text-shadow:0 0 24px #cc3333; }
    #death-flavor { font-size:13px; color:#666; margin:6px 0 20px; letter-spacing:2px; }
    .overlay-hidden { display:none !important; }
  </style>
</head>
<body>
<div id="wrapper">
  <div id="hud">
    <span>ğŸ’€ <span id="score-hud">0</span></span>
    <span>ğŸ“ <span id="length-hud">3</span></span>
    <span>ğŸ† <span id="best-hud">0</span></span>
    <span id="spell-bar">
      <span class="spell-slot" id="slot-0">ğŸ’¥<span class="spell-label">BURST [1]</span></span>
      <span class="spell-slot" id="slot-1">âš¡<span class="spell-label">RUSH [2]</span></span>
      <span class="spell-slot" id="slot-2">ğŸŒ‘<span class="spell-label">SHROUD [3]</span></span>
    </span>
    <span id="effect-hud"></span>
  </div>
  <canvas id="gc" width="800" height="600"></canvas>
</div>

<div id="overlay"></div>

<script>
// â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CELL  = 32;
const COLS  = 30;   // 960px wide
const ROWS  = 20;   // 640px tall
const W = COLS * CELL; // 960
const H = ROWS * CELL; // 640
document.getElementById("gc").width  = W;
document.getElementById("gc").height = H;

const BASE_INTERVAL = 155;

const SPELLS = [
  { name:"BONE BURST",    cost:3, emoji:"ğŸ’¥" },  // 3 segments â†’ blasts 4 cells ahead, 5pts each (max 20pts)
  { name:"SLIME TRAIL",   cost:2, emoji:"ğŸŸ¢" },  // 2 segments â†’ slime trail ~3s
  { name:"DEATH SHROUD",  cost:3, emoji:"ğŸŒ‘" },  // 3 segments (was 4) â†’ 10-tick phase-through
];

// â”€â”€ CANVAS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById("gc");
const ctx    = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false;

// â”€â”€ IMAGE LOADING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 
const IMG = {};

// â”€â”€ AUDIO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SFX = {};
let bgMusic = null;
let audioUnlocked = false;

async function loadAudioChunked(key, basePath, numParts) {
  try {
    const buffers = await Promise.all(
      Array.from({length: numParts}, (_, i) =>
        fetch(`${basePath}.part${i+1}`).then(r => r.arrayBuffer())
      )
    );
    const total = buffers.reduce((n, b) => n + b.byteLength, 0);
    const merged = new Uint8Array(total);
    let offset = 0;
    for (const buf of buffers) { merged.set(new Uint8Array(buf), offset); offset += buf.byteLength; }
    const actx = new (window.AudioContext || window.webkitAudioContext)();
    SFX[key] = await actx.decodeAudioData(merged.buffer);
    SFX[key + '_ctx'] = actx;
  } catch(e) { console.warn('Audio load fail:', key, e); }
}

async function loadAudio(key, src) {
  try {
    const buf = await fetch(src).then(r => r.arrayBuffer());
    const actx = new (window.AudioContext || window.webkitAudioContext)();
    SFX[key] = await actx.decodeAudioData(buf);
    SFX[key + '_ctx'] = actx;
  } catch(e) { console.warn('Audio load fail:', key, e); }
}

function playSound(key, opts={}) {
  const buf = SFX[key];
  const actx = SFX[key + '_ctx'];
  if(!buf || !actx) return;
  try {
    if(actx.state === 'suspended') actx.resume();
    const src = actx.createBufferSource();
    src.buffer = buf;
    if(opts.loop) src.loop = true;
    const gain = actx.createGain();
    gain.gain.value = opts.volume !== undefined ? opts.volume : 1.0;
    src.connect(gain);
    gain.connect(actx.destination);
    src.start(0);
    return { src, gain, actx };
  } catch(e) {}
}

function stopBgMusic() {
  if(bgMusic) { try { bgMusic.src.stop(); } catch(e){} bgMusic = null; }
}

function startBgMusic() {
  stopBgMusic();
  bgMusic = playSound('music', { loop: true, volume: 0.45 });
}

// Unlock audio on first user gesture
function unlockAudio() {
  if(audioUnlocked) return;
  audioUnlocked = true;
  Object.keys(SFX).filter(k => k.endsWith('_ctx')).forEach(k => {
    try { SFX[k].resume(); } catch(e){}
  });
}
document.addEventListener('click', unlockAudio, { once: false });
document.addEventListener('keydown', unlockAudio, { once: false });

// Preload all audio
Promise.all([
  loadAudioChunked('music', 'assets/audio/medievaldeadsong', 6),
  loadAudio('knighthorn', 'assets/audio/knightintrohorn.mp3'),
  loadAudio('knightdeath', 'assets/audio/knightscreamdeath.mp3'),
  loadAudio('snakedeath', 'assets/audio/snakedeath.mp3'),
  loadAudio('villagedeath', 'assets/audio/villagedeath.mp3'),
]).then(() => console.log('Audio ready'));

function loadImg(key, src) {
  return new Promise(res => {
    const i = new Image();
    i.onload  = () => { IMG[key] = i; res(); };
    i.onerror = () => { IMG[key] = null; res(); };
    i.src = src;
  });
}

// â”€â”€ SPRITE HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Snake sheet: 512x512, 2x2 grid â†’ each cell = 256x256
// TL=head, TR=body-straight, BL=body-curve, BR=tail
const SNAKE_CELL = 256;
const SNAKE_MAP  = { head:[0,0], body:[1,0], curve:[0,1], tail:[1,1] };

function drawSnakeSprite(type, x, y, angle) {
  const [sx,sy] = SNAKE_MAP[type] || [1,0];
  ctx.save();
  ctx.translate(x + CELL/2, y + CELL/2);
  if(angle !== undefined) ctx.rotate(angle);
  ctx.drawImage(
    IMG.snake,
    sx * SNAKE_CELL, sy * SNAKE_CELL, SNAKE_CELL, SNAKE_CELL,
    -CELL/2, -CELL/2, CELL, CELL
  );
  ctx.restore();
}

// Villager sheet: 256x64, 4 sprites at 64x64 each
function drawVillagerSprite(frame, x, y) {
  ctx.drawImage(
    IMG.villager,
    frame * 64, 0, 64, 64,
    x, y - Math.round(CELL * 0.4), CELL, Math.round(CELL * 1.4)
  );
}

// Knight sheet: 256x256, 4 rows (dir) Ã— 4 cols (frame), each cell 64x64
// Row 0=down, 1=left, 2=right, 3=up
function drawKnightSprite(frame, dir, x, y) {
  ctx.drawImage(
    IMG.knight,
    frame * 64, dir * 64, 64, 64,
    x - 4, y - Math.round(CELL * 0.5), CELL + 8, Math.round(CELL * 1.5)
  );
}

// Props sheet: 512x512
// Top row: 4 props at 128x128 (cottage=0, well=1, cart=2, tent=3)
// Bottom row: 3 spell orbs at 128x128 (burst=0, rush=1, shroud=2) â€” not used as pickups in this version
const PROP_MAP   = { cottage:0, well:1, cart:2, tent:3 };
function drawPropSprite(type, x, y) {
  const idx = PROP_MAP[type] ?? 0;
  // props.png: 512Ã—128, 4 sprites of 128Ã—128 in a horizontal row
    ctx.drawImage(
    IMG.props,
    idx * 128, 0, 128, 128,
    x - 4, y - 4, CELL + 8, CELL + 8
  );
}

// â”€â”€ GAME STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let snake, dir, nextDir, score, gameOver, intervalId, spellFx, villagers, propList;
let highScore = parseInt(localStorage.getItem("gc_high_score") || "0");

// â”€â”€ GLOBAL LEADERBOARD (Firebase RTDB REST) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FB_URL = "https://pitstop-wall-default-rtdb.firebaseio.com/highscores/grave-crawler";

async function fetchLeaderboard() {
  try {
    const r = await fetch(FB_URL + ".json");
    if(!r.ok) return [];
    const data = await r.json();
    if(!data) return [];
    // Sort client-side (no DB index needed), top 10
    return Object.values(data)
      .sort((a,b) => b.score - a.score)
      .slice(0, 10);
  } catch(e) { return []; }
}

async function submitScore(initials, pts) {
  try {
    await fetch(FB_URL + ".json", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({
        initials: initials.toUpperCase().slice(0,3),
        score: pts,
        ts: Date.now()
      })
    });
  } catch(e) { /* silent fail */ }
}

function renderLeaderboard(rows) {
  if(!rows || rows.length === 0) {
    return `<div style="color:#444;font-size:11px;letter-spacing:2px;font-family:monospace;">NO SCORES YET â€” BE THE FIRST</div>`;
  }
  return `<table style="border-collapse:collapse;width:100%;font-size:12px;letter-spacing:1px;font-family:monospace;">
    <tr>
      <th style="color:#444;padding:2px 8px;text-align:left;font-weight:normal;letter-spacing:2px;">RANK</th>
      <th style="color:#444;padding:2px 8px;text-align:left;font-weight:normal;letter-spacing:2px;">NAME</th>
      <th style="color:#444;padding:2px 8px;text-align:right;font-weight:normal;letter-spacing:2px;">SCORE</th>
    </tr>` +
    rows.map((r,i) => {
      const col = i === 0 ? "#ffd700" : (i < 3 ? "#c8a84b" : "#777");
      return `<tr>
        <td style="color:${col};padding:3px 8px;">#${i+1}</td>
        <td style="color:${col};padding:3px 8px;">${r.initials||"????"}</td>
        <td style="color:${col};padding:2px 8px;text-align:right;">ğŸ’€ ${r.score}</td>
      </tr>`;
    }).join("") +
    "</table>";
}

let pendingScore = 0; // score waiting for initials entry

let shroudTimer = 0, slimeActive = 0; // slimeActive counts down ticks while laying slime
let slimeTiles = []; // [{col,row,life,maxLife}] â€” slime trail tiles
let greenKnight = null;        // active knight NPC or null
let knightAnnounce = 0;        // countdown for announcement banner (frames)
let applesSinceKnight = 0;     // track apples eaten since last knight spawn

// â”€â”€ PROPS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 
function buildProps() {
  const types = ["cottage","well","cart","tent","well","cart","cottage","tent","well","cart"];
  const raw   = [
    {c:1,r:1},{c:23,r:1},{c:1,r:16},{c:23,r:16},
    {c:6,r:2},{c:18,r:2},{c:6,r:15},{c:18,r:15},
    {c:12,r:1},{c:12,r:16}
  ];
  const avoid = new Set();
  const list  = raw.map((p,i) => {
    avoid.add(`${p.c},${p.r}`);
    return { col:p.c, row:p.r, type:types[i] };
  });
  return { list, avoid };
}

// â”€â”€ VILLAGERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 
function makeVillager(propAvoid, snakeSet) {
  let c, r, tries = 0;
  do {
    c = 2 + Math.floor(Math.random() * (COLS - 4));
    r = 2 + Math.floor(Math.random() * (ROWS - 4));
    tries++;
  } while((propAvoid.has(`${c},${r}`) || (snakeSet && snakeSet.has(`${c},${r}`))) && tries < 200);
  return {
    col:c, row:r,
    wanders: Math.random() < 0.4,
    frame:0, frameTimer:0,
    wanderTimer: 4 + Math.floor(Math.random() * 8)
  };
}

function buildVillagers(propAvoid) {
  const vs = [];
  for(let i = 0; i < 8; i++) vs.push(makeVillager(propAvoid, null));
  return vs;
}

function tickVillagers() {
  const snakeSet = new Set(snake.map(s=>`${s.col},${s.row}`));
  const propSet  = new Set(propList.list.map(p=>`${p.col},${p.row}`));
  const head     = snake[0];
  villagers.forEach(v => {
    v.frameTimer++;
    if(v.frameTimer >= 4) { v.frame = (v.frame+1)%4; v.frameTimer=0; }
    if(!v.wanders) return;
    if(--v.wanderTimer > 0) return;
    v.wanderTimer = 4 + Math.floor(Math.random()*8);
    const dirs = [[0,-1],[0,1],[-1,0],[1,0]];
    const valid = dirs.filter(d => {
      const nc = v.col+d[0], nr = v.row+d[1];
      return nc>=1&&nc<COLS-1&&nr>=1&&nr<ROWS-1&&!snakeSet.has(`${nc},${nr}`)&&!propSet.has(`${nc},${nr}`);
    });
    if(!valid.length) return;
    // bias away from snake head
    valid.sort((a,b)=>{
      const da=(v.col+a[0]-head.col)**2+(v.row+a[1]-head.row)**2;
      const db=(v.col+b[0]-head.col)**2+(v.row+b[1]-head.row)**2;
      return db-da;
    });
    const d = Math.random()<0.65 ? valid[0] : valid[Math.floor(Math.random()*valid.length)];
    v.col += d[0]; v.row += d[1];
  });

  // Green Knight update
  if(greenKnight) {
    const k = greenKnight;
    k.frameTimer++;
    if(k.frameTimer >= 3) { k.frame = (k.frame+1)%4; k.frameTimer=0; }
    // Check if snake head landed on knight (every tick, not just move ticks)
    if(k.col===snake[0].col && k.row===snake[0].row) {
      score += 50;
      spellFx.push({type:"eat", col:k.col, row:k.row, life:10, pts:50});
      playSound('knightdeath', { volume: 0.85 });
      greenKnight = null;
      updateHUD();
    } else {
      if(--k.moveTimer <= 0) {
        k.moveTimer = 3;
        const dirs = [[0,-1],[0,1],[-1,0],[1,0]];
        const valid = dirs.filter(d => {
          const nc = k.col+d[0], nr = k.row+d[1];
          return nc>=0&&nc<COLS&&nr>=0&&nr<ROWS&&!snakeSet.has(`${nc},${nr}`);
        });
        if(valid.length) {
          valid.sort((a,b)=>{
            const da=(k.col+a[0]-head.col)**2+(k.row+a[1]-head.row)**2;
            const db=(k.col+b[0]-head.col)**2+(k.row+b[1]-head.row)**2;
            return db-da;
          });
          const d = Math.random()<0.5 ? valid[0] : valid[Math.floor(Math.random()*valid.length)];
          k.col += d[0]; k.row += d[1];
          // Track facing direction: d=[dc,dr] â†’ row in sheet
          if(d[1]>0) k.dir=0;       // moving down
          else if(d[0]<0) k.dir=1;  // moving left
          else if(d[0]>0) k.dir=2;  // moving right
          else if(d[1]<0) k.dir=3;  // moving up
        }
      }
    }
  }
  // Decrement banner independently of knight alive/dead state
  if(knightAnnounce > 0) knightAnnounce--;
}

// â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€ GREEN KNIGHT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnGreenKnight() {
  playSound('knighthorn', { volume: 0.8 });
  // Spawn on a random edge
  const edge = Math.floor(Math.random()*4);
  let col, row;
  if(edge===0) { col=Math.floor(Math.random()*COLS); row=0; }
  else if(edge===1) { col=Math.floor(Math.random()*COLS); row=ROWS-1; }
  else if(edge===2) { col=0; row=Math.floor(Math.random()*ROWS); }
  else              { col=COLS-1; row=Math.floor(Math.random()*ROWS); }
  greenKnight = { col, row, frame:0, frameTimer:0, moveTimer:3, dir:0 }; // dir: 0=down,1=left,2=right,3=up
  knightAnnounce = 20; // ~3 seconds at 155ms/tick
  // Fanfare: short procedural ta-da
  playKnightFanfare();
}

function playKnightFanfare() {
  try {
    const ac = new (window.AudioContext||window.webkitAudioContext)();
    [[523,0],[659,0.15],[784,0.3],[1047,0.45]].forEach(([freq,t]) => {
      const o = ac.createOscillator();
      const g = ac.createGain();
      o.connect(g); g.connect(ac.destination);
      o.type = "square";
      o.frequency.value = freq;
      g.gain.setValueAtTime(0.18, ac.currentTime+t);
      g.gain.exponentialRampToValueAtTime(0.001, ac.currentTime+t+0.18);
      o.start(ac.currentTime+t);
      o.stop(ac.currentTime+t+0.2);
    });
  } catch(e) {}
}

function initGame() {
  const startCol = Math.floor(COLS/2);
  const startRow = Math.floor(ROWS/2);
  snake   = [{col:startCol,row:startRow},{col:startCol-1,row:startRow},{col:startCol-2,row:startRow}];
  dir     = {col:1,row:0};
  nextDir = {col:1,row:0};
  score   = 0; gameOver = false;
  shroudTimer = 0; slimeActive = 0; slimeTiles = [];
  spellFx  = [];
  propList = buildProps();
  villagers = buildVillagers(propList.avoid);
  greenKnight = null; knightAnnounce = 0; applesSinceKnight = 0;
  updateHUD();
}

// â”€â”€ TICK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function tick() {
  if(gameOver) return;
  dir = {...nextDir};
  const head    = snake[0];
  const newHead = { col:head.col+dir.col, row:head.row+dir.row };

  // Wall
  if(newHead.col<0||newHead.col>=COLS||newHead.row<0||newHead.row>=ROWS)
    return endGame("CRUSHED AGAINST THE WALLS");

  // Self
  const bodySet = new Set(snake.map(s=>`${s.col},${s.row}`));
  if(shroudTimer<=0 && bodySet.has(`${newHead.col},${newHead.row}`))
    return endGame("CONSUMED BY YOUR OWN HUNGER");

  // Props: visual only, no collision

  snake.unshift(newHead);

  let ate = false;
  for(let i=0; i<villagers.length; i++) {
    const v = villagers[i];
    if(v.col===newHead.col && v.row===newHead.row) {
      const tailBonus = Math.floor(snake.length / 2);
      score += 10 + tailBonus; ate = true;
      applesSinceKnight++;
      // Spawn Green Knight after 5-10 apples, if not already present
      if(!greenKnight && applesSinceKnight >= 12 + Math.floor(Math.random()*7)) {
        spawnGreenKnight();
        applesSinceKnight = 0;
      }
      spellFx.push({type:"eat", col:v.col, row:v.row, life:10, pts:10 + tailBonus});
      playSound('villagedeath', { volume: 0.6 });
      // Blood splat at eat location â€” fades over 3s (~19 ticks at 155ms)
      spellFx.push({type:"blood", col:v.col, row:v.row, life:19, maxLife:19,
        offsets: Array.from({length:6}, () => ({
          dx: (Math.random()-0.5)*CELL*1.1,
          dy: (Math.random()-0.5)*CELL*1.1,
          r:  3 + Math.random()*5
        }))
      });
      // Respawn
      villagers[i] = makeVillager(propList.avoid, new Set(snake.map(s=>`${s.col},${s.row}`)));
      break;
    }
  }
  if(!ate) snake.pop();

  tickVillagers();

  if(shroudTimer>0) shroudTimer--;
  slimeTiles = slimeTiles.filter(t => { t.life--; return t.life > 0; });
  spellFx = spellFx.filter(e=>{ e.life--; return e.life>0; });

  clearInterval(intervalId);
  intervalId = setInterval(tick, BASE_INTERVAL);

  // Slime trail: if slimeActive, stamp current snake positions as fresh slime
  if(slimeActive > 0) {
    slimeActive--;
    snake.forEach(seg => {
      // avoid duplicate tile at same cell
      if(!slimeTiles.find(t => t.col===seg.col && t.row===seg.row)) {
        slimeTiles.push({ col:seg.col, row:seg.row, life:19, maxLife:19 }); // ~3s at 155ms
      }
    });
  }
  // Villagers on slime get briefly frozen
  villagers.forEach(v => {
    if(slimeTiles.find(t => t.col===v.col && t.row===v.row)) {
      v.frozen = Math.max(v.frozen||0, 6); // freeze for ~1s
    }
  });
  updateHUD();
  draw();
}

// â”€â”€ SPELLS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function castSpell(idx) {
  if(gameOver) return;
  const sp = SPELLS[idx];
  if(snake.length - sp.cost < 3) { showEffect("âš  TOO SMALL TO CAST", 1200); return; }
  for(let i=0;i<sp.cost;i++) snake.pop();

  if(idx===0) {
    for(let i=1;i<=4;i++) {
      const bc=snake[0].col+dir.col*i, br=snake[0].row+dir.row*i;
      spellFx.push({type:"burst",col:bc,row:br,life:14});
      for(let vi=0;vi<villagers.length;vi++) {
        if(villagers[vi].col===bc&&villagers[vi].row===br) {
          score+=5;
          villagers[vi]=makeVillager(propList.avoid, new Set(snake.map(s=>`${s.col},${s.row}`)));
        }
      }
    }
    showEffect("ğŸ’¥ BONE BURST!", 1800);
  } else if(idx===1) {
    slimeActive = 20; // ~3 seconds at 155ms per tick
    showEffect("ğŸŸ¢ SLIME TRAIL!", 1800);
  } else if(idx===2) {
    shroudTimer=10;
    showEffect("ğŸŒ‘ DEATH SHROUD!", 1800);
  }
  updateHUD(); draw();
}

let effectTO;
function showEffect(msg, ms) {
  document.getElementById("effect-hud").textContent = msg;
  clearTimeout(effectTO);
  effectTO = setTimeout(()=>document.getElementById("effect-hud").textContent="", ms);
}

// â”€â”€ HUD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 
function updateHUD() {
  document.getElementById("score-hud").textContent  = score;
  document.getElementById("length-hud").textContent = snake.length;
  document.getElementById("best-hud").textContent   = highScore;
  SPELLS.forEach((sp,i) => {
    const el = document.getElementById("slot-"+i);
    const ready = snake.length > sp.cost + 2;
    el.className = "spell-slot " + (ready ? "ready" : "not-ready");
    if(i===1&&slimeActive>0) el.classList.add("active");
    if(i===2&&shroudTimer>0) el.classList.add("active");
  });
}

// â”€â”€ DRAW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 
function draw() {
  ctx.clearRect(0,0,W,H);

  // Background
  if(IMG.bg) {
    ctx.drawImage(IMG.bg, 0, 0, W, H);
  } else {
    ctx.fillStyle="#151510"; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle="#1e1e16"; ctx.lineWidth=1;
    for(let c=0;c<COLS;c++) for(let r=0;r<ROWS;r++) ctx.strokeRect(c*CELL,r*CELL,CELL,CELL);
  }

  // Death shroud tint
  if(shroudTimer>0) {
    ctx.fillStyle=`rgba(20,0,50,${0.4*(shroudTimer/10)})`;
    ctx.fillRect(0,0,W,H);
  }

  // Props
  propList.list.forEach(p => {
    const x=p.col*CELL, y=p.row*CELL;
    if(IMG.props) {
      drawPropSprite(p.type, x, y);
    } else {
      ctx.fillStyle="#443322"; ctx.fillRect(x+2,y+2,CELL-4,CELL-4);
      ctx.fillStyle="#221108"; ctx.font="18px serif"; ctx.textAlign="center";
      ctx.fillText("ğŸ ",x+CELL/2,y+CELL/2+6);
    }
  });

  // Villagers
  villagers.forEach(v => {
    const x=v.col*CELL, y=v.row*CELL;
    if(IMG.villager) {
      drawVillagerSprite(v.frame, x, y);
    } else {
      // fallback: tiny figure
      ctx.fillStyle="#c8884b";
      ctx.fillRect(x+10,y+8,12,18);
      ctx.fillStyle="#f0c070";
      ctx.beginPath(); ctx.arc(x+16,y+6,5,0,Math.PI*2); ctx.fill();
    }
  });

  // Green Knight
  if(greenKnight) {
    const x = greenKnight.col*CELL, y = greenKnight.row*CELL;
    if(IMG.knight) {
      drawKnightSprite(greenKnight.frame, greenKnight.dir, x, y);
    } else {
      ctx.fillStyle="#22bb22";
      ctx.fillRect(x+8, y+4, CELL-16, CELL-8);
    }
  }

  // Green Knight announcement banner
  if(knightAnnounce > 0) {
    // fade in over first 10 frames, fade out over last 20 frames
    const fadeIn  = Math.min(1, (90 - knightAnnounce) / 10);
    const fadeOut = Math.min(1, knightAnnounce / 10);
    ctx.save();
    ctx.globalAlpha = Math.min(fadeIn, fadeOut);
    ctx.fillStyle = "rgba(10,40,10,0.82)";
    ctx.fillRect(W/2 - 240, H/2 - 36, 480, 64);
    ctx.strokeStyle = "#44ff44";
    ctx.lineWidth = 2;
    ctx.strokeRect(W/2 - 240, H/2 - 36, 480, 64);
    ctx.fillStyle = "#44ff44";
    ctx.font = "bold 22px 'Courier New', monospace";
    ctx.textAlign = "center";
    ctx.shadowColor = "#44ff44"; ctx.shadowBlur = 14;
    ctx.fillText("âš”  THE GREEN KNIGHT APPROACHES  âš”", W/2, H/2 + 8);
    ctx.restore();
  }

  // Spell FX
  // Draw slime tiles (render under spellFx, above background)
  slimeTiles.forEach(t => {
    const alpha = (t.life / t.maxLife) * 0.65; // fade from 65% to 0
    const x = t.col * CELL, y = t.row * CELL;
    ctx.save();
    ctx.globalAlpha = alpha;
    // Slime puddle: dark yellow-green blob
    ctx.fillStyle = '#5aaf1a';
    ctx.shadowColor = '#7fff00'; ctx.shadowBlur = 6;
    ctx.beginPath();
    ctx.ellipse(x + CELL*0.5, y + CELL*0.55, CELL*0.42, CELL*0.32, 0, 0, Math.PI*2);
    ctx.fill();
    // Inner highlight
    ctx.globalAlpha = alpha * 0.5;
    ctx.fillStyle = '#a8ff3e';
    ctx.shadowBlur = 0;
    ctx.beginPath();
    ctx.ellipse(x + CELL*0.45, y + CELL*0.48, CELL*0.18, CELL*0.12, -0.3, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  });

  spellFx.forEach(e => {
    const x=e.col*CELL, y=e.row*CELL;
    if(e.type==="blood") {
      const t = e.life / e.maxLife;
      ctx.save();
      ctx.globalAlpha = t * 0.75;
      ctx.fillStyle = "#8b0000";
      const cx = e.col * CELL + CELL / 2;
      const cy = e.row * CELL + CELL / 2;
      e.offsets.forEach(o => {
        ctx.beginPath();
        ctx.arc(cx + o.dx, cy + o.dy, o.r * (0.5 + 0.5 * t), 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.restore();
    } else if(e.type==="burst") {
      const t=e.life/14;
      ctx.save();
      ctx.globalAlpha=t;
      ctx.shadowColor="#ff7020"; ctx.shadowBlur=20;
      ctx.fillStyle=`rgb(255,${Math.floor(80+120*t)},20)`;
      const r=(CELL/2)*t+6;
      ctx.beginPath(); ctx.arc(x+CELL/2,y+CELL/2,r,0,Math.PI*2); ctx.fill();
      ctx.restore();
    } else if(e.type==="eat") {
      ctx.save();
      ctx.globalAlpha=e.life/10;
      ctx.fillStyle="#c8a84b";
      ctx.font=`bold ${13+(10-e.life)}px 'Courier New'`;
      ctx.textAlign="center";
      ctx.shadowColor="#c8a84b"; ctx.shadowBlur=8;
      ctx.fillText("+"+(e.pts||10), x+CELL/2, y - (10-e.life)*2);
      ctx.restore();
    }
  });

  // Snake
  drawSnake();
}

function drawSnake() {
  const len = snake.length;
  snake.forEach((seg, i) => {
    const x=seg.col*CELL, y=seg.row*CELL;
    const alpha = shroudTimer>0 ? (0.4+0.6*Math.sin(Date.now()/60)) : 1;

    if(IMG.snake) {
      ctx.save();
      ctx.globalAlpha = alpha;
      if(i===0) {
        // Head: rotate to face direction
        // Sprite faces DOWN natively; subtract Ï€/2 to rotate CCW 90Â° â†’ faces RIGHT at angle=0
        const angle = Math.atan2(dir.row, dir.col) - Math.PI/2;
        drawSnakeSprite("head", x, y, angle);
      } else if(i===len-1) {
        // Tail: point away from body; +Ï€/2 offset mirrors head's -Ï€/2 (opposite correction)
        const prev = snake[i-1];
        const angle = Math.atan2(seg.row-prev.row, seg.col-prev.col) + Math.PI/2 + Math.PI;
        drawSnakeSprite("tail", x, y, angle);
      } else {
        // Body: detect corner vs straight
        const prev=snake[i-1], next=snake[i+1];
        const dx1=prev.col-seg.col, dy1=prev.row-seg.row;
        const dx2=next.col-seg.col, dy2=next.row-seg.row;
        const straight = (dx1===-dx2) || (dy1===-dy2);
        if(straight) {
          // Use head-side to tail-side travel angle; ribs need +Ï€/2 to stay perpendicular to travel
          const travelAngle = Math.atan2(prev.row - next.row, prev.col - next.col);
          drawSnakeSprite("body", x, y, travelAngle + Math.PI/2);
        } else {
          // Corner: use diagonal between the two incoming directions
          const travelAngle = Math.atan2(prev.row - next.row, prev.col - next.col);
          drawSnakeSprite("curve", x, y, travelAngle + Math.PI/4);
        }
      }
      ctx.restore();
    } else {
      // Procedural fallback
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = i===0 ? "#d0bc88" : (i%2===0?"#a8926a":"#907854");
      const p=i===0?2:3;
      ctx.fillRect(x+p,y+p,CELL-p*2,CELL-p*2);
      if(i===0) {
        ctx.fillStyle="#ff4400"; ctx.shadowColor="#ff4400"; ctx.shadowBlur=10;
        ctx.fillRect(x+CELL/2-7+dir.col*5, y+CELL/2-3+dir.row*5, 4,4);
        ctx.fillRect(x+CELL/2+3+dir.col*5, y+CELL/2-3+dir.row*5, 4,4);
        ctx.shadowBlur=0;
      }
      ctx.restore();
    }
  });
}

// â”€â”€ END GAME â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const DEATHS = [
  "THE GRAVE RECLAIMS ITS OWN",
  "SILENCE FALLS OVER THE RUINS",
  "THE WYRM CRUMBLES TO DUST",
  "ANOTHER SOUL FOR THE EARTH",
  "THE BONES RETURN TO DUST",
];
function endGame(reason) {
  gameOver = true;
  clearInterval(intervalId);
  stopBgMusic();
  playSound('snakedeath', { volume: 0.9 });
  // Save local high score
  if(score > highScore) {
    highScore = score;
    localStorage.setItem("gc_high_score", highScore);
  }
  draw();
  pendingScore = score;
  showInitialsEntry(reason, score >= highScore && score > 0);
}

async function showInitialsEntry(reason, isNew) {
  const finalScore = pendingScore;
  const ov = document.getElementById("overlay");
  // Solid dark background â€” no jumping background art
  ov.style.background = "radial-gradient(ellipse at center, #0d0d12 0%, #050508 100%)";
  ov.innerHTML = `
    <div style="
      background:rgba(0,0,0,0.82);
      border:1px solid #2a2a1a;
      border-radius:8px;
      padding:28px 36px;
      max-width:440px;
      width:90%;
      text-align:center;
      box-shadow:0 0 60px #000, inset 0 0 30px rgba(200,168,75,0.04);
      font-family:'Courier New',monospace;
    ">
      <div style="font-size:28px;color:#cc3333;letter-spacing:6px;text-shadow:0 0 20px #cc3333aa;margin-bottom:6px;font-weight:900;">THE CRAWLER FALLS</div>
      <div style="font-size:11px;color:#664444;letter-spacing:3px;margin-bottom:18px;text-transform:uppercase;">${reason}</div>
      <div style="font-size:48px;color:#c8a84b;text-shadow:0 0 20px #c8a84b88;margin-bottom:4px;">ğŸ’€ ${finalScore}</div>
      ${isNew ? '<div style="color:#ffd700;font-size:13px;letter-spacing:4px;margin-bottom:4px;text-shadow:0 0 12px #ffd700;">âœ¦ NEW HIGH SCORE âœ¦</div>' : ''}
      <div style="color:#555;font-size:11px;letter-spacing:2px;margin-bottom:20px;">BEST: ${highScore}</div>
      <div style="border-top:1px solid #1a1a1a;margin-bottom:18px;padding-top:16px;">
        <div style="font-size:10px;letter-spacing:3px;color:#666;margin-bottom:10px;">CARVE YOUR NAME INTO THE BONES</div>
        <input id="initials-input" maxlength="3" placeholder="AAA"
          style="background:#0a0a0a;border:2px solid #c8a84b;color:#c8a84b;
                 font-family:'Courier New',monospace;font-size:30px;letter-spacing:12px;
                 text-align:center;width:130px;padding:8px;text-transform:uppercase;
                 outline:none;border-radius:4px;" />
      </div>
      <div id="lb-submitting" style="font-size:10px;color:#c8a84b88;letter-spacing:2px;min-height:16px;margin-bottom:10px;"></div>
      <div style="display:flex;gap:12px;justify-content:center;margin-bottom:22px;">
        <button id="submit-score-btn" style="
          padding:10px 24px;font-size:13px;letter-spacing:3px;
          background:transparent;border:2px solid #c8a84b;color:#c8a84b;
          font-family:'Courier New',monospace;cursor:pointer;
          transition:all .2s;text-transform:uppercase;border-radius:4px;
        " onmouseover="this.style.background='#c8a84b22'" onmouseout="this.style.background='transparent'">INSCRIBE</button>
        <button id="skip-score-btn" style="
          padding:10px 18px;font-size:11px;letter-spacing:2px;
          background:transparent;border:2px solid #333;color:#555;
          font-family:'Courier New',monospace;cursor:pointer;
          transition:all .2s;text-transform:uppercase;border-radius:4px;
        " onmouseover="this.style.color='#888'" onmouseout="this.style.color='#555'">SKIP</button>
      </div>
      <div id="lb-container" style="min-height:80px;"></div>
      <div style="display:flex;gap:12px;justify-content:center;margin-top:20px;border-top:1px solid #1a1a1a;padding-top:18px;">
        <button id="replay-btn" style="
          padding:12px 32px;font-size:15px;letter-spacing:4px;
          background:transparent;border:2px solid #c8a84b;color:#c8a84b;
          font-family:'Courier New',monospace;cursor:pointer;
          transition:all .2s;text-transform:uppercase;border-radius:4px;
        " onmouseover="this.style.background='#c8a84b22'" onmouseout="this.style.background='transparent'">RISE AGAIN</button>
        <button id="title-btn" style="
          padding:12px 22px;font-size:13px;letter-spacing:3px;
          background:transparent;border:2px solid #333;color:#666;
          font-family:'Courier New',monospace;cursor:pointer;
          transition:all .2s;text-transform:uppercase;border-radius:4px;
        " onmouseover="this.style.color='#aaa';this.style.borderColor='#666'" onmouseout="this.style.color='#666';this.style.borderColor='#333'">â—€ TITLE</button>
      </div>
    </div>
  `;
  ov.classList.remove("overlay-hidden");

  // Auto-uppercase input
  const inp = document.getElementById("initials-input");
  inp.addEventListener("input", () => { inp.value = inp.value.toUpperCase(); });
  inp.focus();

  // Load leaderboard in background
  const lbContainer = document.getElementById("lb-container");
  lbContainer.innerHTML = '<div style="color:#556;font-size:10px;letter-spacing:2px;">LOADING HALL OF THE DEAD...</div>';
  const rows = await fetchLeaderboard();
  lbContainer.innerHTML = renderLeaderboard(rows);

  async function doSubmit() {
    const initials = inp.value.trim().padEnd(3,"?").slice(0,3).toUpperCase();
    const btn = document.getElementById("submit-score-btn");
    const status = document.getElementById("lb-submitting");
    if(btn) btn.disabled = true;
    if(status) status.textContent = "INSCRIBING...";
    await submitScore(initials, finalScore);
    // Refresh leaderboard
    const updated = await fetchLeaderboard();
    const lb2 = document.getElementById("lb-container");
    if(lb2) lb2.innerHTML = renderLeaderboard(updated);
    if(status) status.textContent = "INSCRIBED IN THE BONES âœ¦";
    if(btn) btn.style.display = "none";
    const skipBtn = document.getElementById("skip-score-btn");
    if(skipBtn) skipBtn.style.display = "none";
  }

  document.getElementById("submit-score-btn").addEventListener("click", doSubmit);
  document.getElementById("skip-score-btn").addEventListener("click", async () => {
    document.getElementById("skip-score-btn").style.display="none";
    document.getElementById("submit-score-btn").style.display="none";
    const rows2 = await fetchLeaderboard();
    const lb2 = document.getElementById("lb-container");
    if(lb2) lb2.innerHTML = renderLeaderboard(rows2);
  });

  // Enter key submits
  inp.addEventListener("keydown", e => { if(e.key==="Enter") doSubmit(); });

  document.getElementById("replay-btn").addEventListener("click", startGame);
  document.getElementById("title-btn").addEventListener("click", showTitleScreen);
}

// â”€â”€ INPUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 
const KEYS = {
  ArrowUp:{col:0,row:-1}, ArrowDown:{col:0,row:1},
  ArrowLeft:{col:-1,row:0}, ArrowRight:{col:1,row:0},
  w:{col:0,row:-1}, s:{col:0,row:1}, a:{col:-1,row:0}, d:{col:1,row:0},
  W:{col:0,row:-1}, S:{col:0,row:1}, A:{col:-1,row:0}, D:{col:1,row:0},
};
document.addEventListener("keydown", e => {
  // Don't steal keys while user is typing in the initials box
  if(document.activeElement && document.activeElement.id === "initials-input") return;
  if(KEYS[e.key]) {
    e.preventDefault();
    const nd=KEYS[e.key];
    if(nd.col !== -dir.col || nd.row !== -dir.row) nextDir = nd;
  }
  if(e.key==="1") { e.preventDefault(); castSpell(0); }
  if(e.key==="2") { e.preventDefault(); castSpell(1); }
  if(e.key==="3") { e.preventDefault(); castSpell(2); }
});

// â”€â”€ START â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 
async function showTitleScreen() {
  clearInterval(intervalId);
  gameOver = true;
  const ov = document.getElementById("overlay");
  ov.innerHTML = `
    <div style="position:relative;width:100%;height:100%;overflow:hidden;">
      ${IMG.title ? '<img src="' + IMG.title.src + '" style="position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;opacity:0.55;">' : ''}
      <div style="position:relative;z-index:2;display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;gap:0;overflow-y:auto;padding:16px 0;">
        <h1 style="font-size:clamp(28px,5vw,52px);letter-spacing:8px;text-shadow:0 0 32px #33ff66,0 0 8px #000;margin-bottom:4px;">GRAVE CRAWLER</h1>
        <h2 style="font-size:13px;letter-spacing:4px;color:#aaddaa;margin-bottom:12px;">ARISE. DEVOUR. GROW.</h2>
        <!-- Info sheet -->
        <div style="background:rgba(0,0,0,0.65);border:1px solid #2a3a2a;border-radius:6px;padding:12px 20px;margin-bottom:12px;text-align:center;">
          <div style="font-size:11px;color:#99aa99;margin-bottom:4px;letter-spacing:2px;">Arrow keys / WASD â€” Slither</div>
          <div style="font-size:11px;color:#99aa99;margin-bottom:4px;">1 â€” ğŸ’¥ Bone Burst &nbsp; 2 â€” ğŸŸ¢ Slime Trail &nbsp; 3 â€” ğŸŒ‘ Death Shroud</div>
          <div style="font-size:10px;color:#88aa88;margin-bottom:8px;letter-spacing:1px;">Spells consume your body â€” do not cast when small!</div>
        </div>
        <div style="background:rgba(0,0,0,0.65);border:1px solid rgba(200,168,75,0.3);border-radius:6px;padding:14px 24px;margin-bottom:14px;"><button id="start-btn" style="font-size:17px;padding:12px 36px;letter-spacing:4px;">CRAWL FORTH</button></div>
        <!-- Leaderboard sheet -->
        <div style="background:rgba(0,0,0,0.65);border:1px solid #2a2a3a;border-radius:6px;padding:10px 16px;width:300px;text-align:center;">
          <div style="font-size:10px;letter-spacing:3px;color:#888;margin-bottom:8px;">â€” HALL OF THE DEAD â€”</div>
          <div id="title-leaderboard"></div>
        </div>
      </div>
    </div>
  `;
  ov.style.padding = "0";
  ov.style.background = ""; // reset from game-over gradient
  ov.classList.remove("overlay-hidden");
  stopBgMusic(); // music restarts on CRAWL FORTH click
  document.getElementById("start-btn").addEventListener("click", () => {
    ov.style.padding = "";
    startGame();
  });
  // Async leaderboard load
  const lbDiv = document.getElementById("title-leaderboard");
  if(lbDiv) {
    lbDiv.innerHTML = '<div style="color:#556;font-size:10px;letter-spacing:2px;">LOADING...</div>';
    const rows = await fetchLeaderboard();
    lbDiv.innerHTML = renderLeaderboard(rows);
  }
}

function startGame() {
  unlockAudio();
  startBgMusic();
  document.getElementById("overlay").classList.add("overlay-hidden");
  initGame();
  clearInterval(intervalId);
  intervalId = setInterval(tick, BASE_INTERVAL);
  draw();
}

// â”€â”€ BOOT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 
Promise.all([
  loadImg("bg",      "assets/bg.jpg"),
  loadImg("title",   "assets/title.jpg"),
  loadImg("snake",   "assets/snake.png"),
  loadImg("villager","assets/villager.png"),
  loadImg("props",   "assets/props.png"),
  loadImg("knight",  "assets/knight.png"),
]).then(() => {
  // Runtime magenta-kill: nuke any pixel where R > G+55 && B > G+55
  // Catches JPEG-compressed fringe that survives PNG alpha keying
  function killMagenta(imgEl) {
    if (!imgEl) return imgEl;
    const oc = document.createElement('canvas');
    oc.width = imgEl.naturalWidth; oc.height = imgEl.naturalHeight;
    const ox = oc.getContext('2d');
    ox.drawImage(imgEl, 0, 0);
    const id = ox.getImageData(0, 0, oc.width, oc.height);
    const d = id.data;
    for (let i = 0; i < d.length; i += 4) {
      const r = d[i], g = d[i+1], b = d[i+2];
      if (r - g > 55 && b - g > 55) { d[i+3] = 0; }
      else if (r - g > 25 && b - g > 25) {
        const s = Math.min((r-g-25)/30, (b-g-25)/30, 1);
        d[i+3] = Math.round(d[i+3] * (1 - s));
      }
    }
    ox.putImageData(id, 0, 0);
    return oc;
  }
  IMG.knight = killMagenta(IMG.knight);
  showTitleScreen();
}).catch(() => {
  showTitleScreen();
});
</script>
</body>
</html>
