<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Grave Crawler</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      background:#0a0a0a;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      min-height:100vh; overflow:hidden;
      font-family:'Courier New', monospace;
    }
    #wrapper { display:flex; flex-direction:column; align-items:center; gap:8px; }
    #hud {
      display:flex; gap:20px; align-items:center;
      color:#c8a84b; font-size:14px; letter-spacing:2px;
      text-shadow:0 0 8px #c8a84b88; padding:4px 0;
    }
    #spell-bar { display:flex; gap:8px; align-items:center; }
    .spell-slot {
      width:38px; height:38px; border:2px solid #444;
      border-radius:4px; display:flex; align-items:center; justify-content:center;
      font-size:18px; cursor:pointer; background:#111; position:relative;
      transition:border-color .15s, background .15s;
      user-select:none;
    }
    .spell-slot.ready  { border-color:#c8a84b; box-shadow:0 0 10px #c8a84b44; }
    .spell-slot.active { border-color:#fff; background:#1a1a2a; }
    .spell-slot.not-ready { opacity:0.4; }
    .spell-label {
      position:absolute; bottom:-18px; left:50%; transform:translateX(-50%);
      font-size:9px; color:#888; white-space:nowrap; letter-spacing:1px;
    }
    canvas {
      display:block;
      image-rendering:pixelated; image-rendering:crisp-edges;
      border:2px solid #2a1a0a;
      box-shadow:0 0 60px #000000cc, 0 0 20px #1a0a0088;
    }
    #effect-hud { color:#aaa; font-size:12px; min-width:140px; text-align:center; }
    #overlay {
      position:fixed; inset:0; background:#000000dd;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      z-index:10; color:#c8a84b;
    }
    #overlay h1 {
      font-size:52px; letter-spacing:10px; text-shadow:0 0 30px #c8a84b, 0 0 60px #c8a84b44;
      margin-bottom:8px; font-weight:900;
    }
    #overlay h2 { font-size:18px; color:#777; letter-spacing:4px; margin-bottom:36px; }
    #overlay p  { color:#999; font-size:13px; letter-spacing:1px; margin:3px 0; }
    .spell-hint { color:#c8a84b66; font-size:11px; margin-top:10px; }
    #start-btn {
      margin-top:36px; padding:14px 56px; background:transparent;
      border:2px solid #c8a84b; color:#c8a84b; font-size:18px;
      letter-spacing:6px; cursor:pointer; font-family:inherit;
      text-transform:uppercase; transition:all .2s;
    }
    #start-btn:hover { background:#c8a84b22; box-shadow:0 0 24px #c8a84b88; }
    #score-big { font-size:42px; margin:10px 0; }
    #game-over-msg { font-size:30px; color:#cc3333; letter-spacing:6px; text-shadow:0 0 24px #cc3333; }
    #death-flavor { font-size:13px; color:#666; margin:6px 0 20px; letter-spacing:2px; }
    .overlay-hidden { display:none !important; }
  </style>
</head>
<body>
<div id="wrapper">
  <div id="hud">
    <span>ğŸ’€ <span id="score-hud">0</span></span>
    <span>ğŸ“ <span id="length-hud">3</span></span>
    <span id="spell-bar">
      <span class="spell-slot" id="slot-0">ğŸ’¥<span class="spell-label">BURST [1]</span></span>
      <span class="spell-slot" id="slot-1">âš¡<span class="spell-label">RUSH [2]</span></span>
      <span class="spell-slot" id="slot-2">ğŸŒ‘<span class="spell-label">SHROUD [3]</span></span>
    </span>
    <span id="effect-hud"></span>
  </div>
  <canvas id="gc" width="800" height="600"></canvas>
</div>

<div id="overlay">
  <h1>GRAVE CRAWLER</h1>
  <h2>ARISE. DEVOUR. GROW.</h2>
  <p>Arrow keys / WASD â€” Slither</p>
  <p>1 â€” ğŸ’¥ Bone Burst (costs 3 segments â€” clears path ahead)</p>
  <p>2 â€” ğŸŸ¢ Slime Trail (costs 2 segments â€” leaves toxic slime, fades in 3s)</p>
  <p>3 â€” ğŸŒ‘ Death Shroud (costs 4 segments â€” brief invincibility)</p>
  <p class="spell-hint">Spells consume your body â€” do not cast when small!</p>
  <button id="start-btn">CRAWL FORTH</button>
</div>

<script>
// â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CELL  = 32;
const COLS  = 30;   // 960px wide
const ROWS  = 20;   // 640px tall
const W = COLS * CELL; // 960
const H = ROWS * CELL; // 640
document.getElementById("gc").width  = W;
document.getElementById("gc").height = H;

const BASE_INTERVAL = 155;

const SPELLS = [
  { name:"BONE BURST",    cost:3, emoji:"ğŸ’¥" },
  { name:"SLIME TRAIL",   cost:2, emoji:"ğŸŸ¢" },
  { name:"DEATH SHROUD",  cost:4, emoji:"ğŸŒ‘" },
];

// â”€â”€ CANVAS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById("gc");
const ctx    = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false;

// â”€â”€ IMAGE LOADING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 
const IMG = {};
function loadImg(key, src) {
  return new Promise(res => {
    const i = new Image();
    i.onload  = () => { IMG[key] = i; res(); };
    i.onerror = () => { IMG[key] = null; res(); };
    i.src = src;
  });
}

// â”€â”€ SPRITE HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Snake sheet: 512x512, 2x2 grid â†’ each cell = 256x256
// TL=head, TR=body-straight, BL=body-curve, BR=tail
const SNAKE_CELL = 256;
const SNAKE_MAP  = { head:[0,0], body:[1,0], curve:[0,1], tail:[1,1] };

function drawSnakeSprite(type, x, y, angle) {
  const [sx,sy] = SNAKE_MAP[type] || [1,0];
  ctx.save();
  ctx.translate(x + CELL/2, y + CELL/2);
  if(angle !== undefined) ctx.rotate(angle);
  ctx.drawImage(
    IMG.snake,
    sx * SNAKE_CELL, sy * SNAKE_CELL, SNAKE_CELL, SNAKE_CELL,
    -CELL/2, -CELL/2, CELL, CELL
  );
  ctx.restore();
}

// Villager sheet: 256x64, 4 sprites at 64x64 each
function drawVillagerSprite(frame, x, y) {
  ctx.drawImage(
    IMG.villager,
    frame * 64, 0, 64, 64,
    x, y - Math.round(CELL * 0.4), CELL, Math.round(CELL * 1.4)
  );
}

// Knight sheet: 256x256, 4 rows (dir) Ã— 4 cols (frame), each cell 64x64
// Row 0=down, 1=left, 2=right, 3=up
function drawKnightSprite(frame, dir, x, y) {
  ctx.drawImage(
    IMG.knight,
    frame * 64, dir * 64, 64, 64,
    x - 4, y - Math.round(CELL * 0.5), CELL + 8, Math.round(CELL * 1.5)
  );
}

// Props sheet: 512x512
// Top row: 4 props at 128x128 (cottage=0, well=1, cart=2, tent=3)
// Bottom row: 3 spell orbs at 128x128 (burst=0, rush=1, shroud=2) â€” not used as pickups in this version
const PROP_MAP   = { cottage:0, well:1, cart:2, tent:3 };
function drawPropSprite(type, x, y) {
  const idx = PROP_MAP[type] ?? 0;
  // props.png: 512Ã—128, 4 sprites of 128Ã—128 in a horizontal row
    ctx.drawImage(
    IMG.props,
    idx * 128, 0, 128, 128,
    x - 4, y - 4, CELL + 8, CELL + 8
  );
}

// â”€â”€ GAME STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let snake, dir, nextDir, score, gameOver, intervalId, spellFx, villagers, propList;
let shroudTimer = 0, slimeActive = 0; // slimeActive counts down ticks while laying slime
let slimeTiles = []; // [{col,row,life,maxLife}] â€” slime trail tiles
let greenKnight = null;        // active knight NPC or null
let knightAnnounce = 0;        // countdown for announcement banner (frames)
let applesSinceKnight = 0;     // track apples eaten since last knight spawn

// â”€â”€ PROPS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 
function buildProps() {
  const types = ["cottage","well","cart","tent","well","cart","cottage","tent","well","cart"];
  const raw   = [
    {c:1,r:1},{c:23,r:1},{c:1,r:16},{c:23,r:16},
    {c:6,r:2},{c:18,r:2},{c:6,r:15},{c:18,r:15},
    {c:12,r:1},{c:12,r:16}
  ];
  const avoid = new Set();
  const list  = raw.map((p,i) => {
    avoid.add(`${p.c},${p.r}`);
    return { col:p.c, row:p.r, type:types[i] };
  });
  return { list, avoid };
}

// â”€â”€ VILLAGERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 
function makeVillager(propAvoid, snakeSet) {
  let c, r, tries = 0;
  do {
    c = 2 + Math.floor(Math.random() * (COLS - 4));
    r = 2 + Math.floor(Math.random() * (ROWS - 4));
    tries++;
  } while((propAvoid.has(`${c},${r}`) || (snakeSet && snakeSet.has(`${c},${r}`))) && tries < 200);
  return {
    col:c, row:r,
    wanders: Math.random() < 0.4,
    frame:0, frameTimer:0,
    wanderTimer: 4 + Math.floor(Math.random() * 8)
  };
}

function buildVillagers(propAvoid) {
  const vs = [];
  for(let i = 0; i < 8; i++) vs.push(makeVillager(propAvoid, null));
  return vs;
}

function tickVillagers() {
  const snakeSet = new Set(snake.map(s=>`${s.col},${s.row}`));
  const propSet  = new Set(propList.list.map(p=>`${p.col},${p.row}`));
  const head     = snake[0];
  villagers.forEach(v => {
    v.frameTimer++;
    if(v.frameTimer >= 4) { v.frame = (v.frame+1)%4; v.frameTimer=0; }
    if(!v.wanders) return;
    if(--v.wanderTimer > 0) return;
    v.wanderTimer = 4 + Math.floor(Math.random()*8);
    const dirs = [[0,-1],[0,1],[-1,0],[1,0]];
    const valid = dirs.filter(d => {
      const nc = v.col+d[0], nr = v.row+d[1];
      return nc>=1&&nc<COLS-1&&nr>=1&&nr<ROWS-1&&!snakeSet.has(`${nc},${nr}`)&&!propSet.has(`${nc},${nr}`);
    });
    if(!valid.length) return;
    // bias away from snake head
    valid.sort((a,b)=>{
      const da=(v.col+a[0]-head.col)**2+(v.row+a[1]-head.row)**2;
      const db=(v.col+b[0]-head.col)**2+(v.row+b[1]-head.row)**2;
      return db-da;
    });
    const d = Math.random()<0.65 ? valid[0] : valid[Math.floor(Math.random()*valid.length)];
    v.col += d[0]; v.row += d[1];
  });

  // Green Knight update
  if(greenKnight) {
    const k = greenKnight;
    k.frameTimer++;
    if(k.frameTimer >= 3) { k.frame = (k.frame+1)%4; k.frameTimer=0; }
    // Check if snake head landed on knight (every tick, not just move ticks)
    if(k.col===snake[0].col && k.row===snake[0].row) {
      score += 50;
      spellFx.push({type:"eat", col:k.col, row:k.row, life:10});
      greenKnight = null;
      updateHUD();
    } else {
      if(--k.moveTimer <= 0) {
        k.moveTimer = 3;
        const dirs = [[0,-1],[0,1],[-1,0],[1,0]];
        const valid = dirs.filter(d => {
          const nc = k.col+d[0], nr = k.row+d[1];
          return nc>=0&&nc<COLS&&nr>=0&&nr<ROWS&&!snakeSet.has(`${nc},${nr}`);
        });
        if(valid.length) {
          valid.sort((a,b)=>{
            const da=(k.col+a[0]-head.col)**2+(k.row+a[1]-head.row)**2;
            const db=(k.col+b[0]-head.col)**2+(k.row+b[1]-head.row)**2;
            return db-da;
          });
          const d = Math.random()<0.5 ? valid[0] : valid[Math.floor(Math.random()*valid.length)];
          k.col += d[0]; k.row += d[1];
          // Track facing direction: d=[dc,dr] â†’ row in sheet
          if(d[1]>0) k.dir=0;       // moving down
          else if(d[0]<0) k.dir=1;  // moving left
          else if(d[0]>0) k.dir=2;  // moving right
          else if(d[1]<0) k.dir=3;  // moving up
        }
      }
    }
  }
  // Decrement banner independently of knight alive/dead state
  if(knightAnnounce > 0) knightAnnounce--;
}

// â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€ GREEN KNIGHT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnGreenKnight() {
  // Spawn on a random edge
  const edge = Math.floor(Math.random()*4);
  let col, row;
  if(edge===0) { col=Math.floor(Math.random()*COLS); row=0; }
  else if(edge===1) { col=Math.floor(Math.random()*COLS); row=ROWS-1; }
  else if(edge===2) { col=0; row=Math.floor(Math.random()*ROWS); }
  else              { col=COLS-1; row=Math.floor(Math.random()*ROWS); }
  greenKnight = { col, row, frame:0, frameTimer:0, moveTimer:3, dir:0 }; // dir: 0=down,1=left,2=right,3=up
  knightAnnounce = 90; // show banner for ~1.5 seconds (60fps)
  // Fanfare: short procedural ta-da
  playKnightFanfare();
}

function playKnightFanfare() {
  try {
    const ac = new (window.AudioContext||window.webkitAudioContext)();
    [[523,0],[659,0.15],[784,0.3],[1047,0.45]].forEach(([freq,t]) => {
      const o = ac.createOscillator();
      const g = ac.createGain();
      o.connect(g); g.connect(ac.destination);
      o.type = "square";
      o.frequency.value = freq;
      g.gain.setValueAtTime(0.18, ac.currentTime+t);
      g.gain.exponentialRampToValueAtTime(0.001, ac.currentTime+t+0.18);
      o.start(ac.currentTime+t);
      o.stop(ac.currentTime+t+0.2);
    });
  } catch(e) {}
}

function initGame() {
  const startCol = Math.floor(COLS/2);
  const startRow = Math.floor(ROWS/2);
  snake   = [{col:startCol,row:startRow},{col:startCol-1,row:startRow},{col:startCol-2,row:startRow}];
  dir     = {col:1,row:0};
  nextDir = {col:1,row:0};
  score   = 0; gameOver = false;
  shroudTimer = 0; slimeActive = 0; slimeTiles = [];
  spellFx  = [];
  propList = buildProps();
  villagers = buildVillagers(propList.avoid);
  greenKnight = null; knightAnnounce = 0; applesSinceKnight = 0;
  updateHUD();
}

// â”€â”€ TICK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function tick() {
  if(gameOver) return;
  dir = {...nextDir};
  const head    = snake[0];
  const newHead = { col:head.col+dir.col, row:head.row+dir.row };

  // Wall
  if(newHead.col<0||newHead.col>=COLS||newHead.row<0||newHead.row>=ROWS)
    return endGame("CRUSHED AGAINST THE WALLS");

  // Self
  const bodySet = new Set(snake.map(s=>`${s.col},${s.row}`));
  if(shroudTimer<=0 && bodySet.has(`${newHead.col},${newHead.row}`))
    return endGame("CONSUMED BY YOUR OWN HUNGER");

  // Props: visual only, no collision

  snake.unshift(newHead);

  let ate = false;
  for(let i=0; i<villagers.length; i++) {
    const v = villagers[i];
    if(v.col===newHead.col && v.row===newHead.row) {
      score += 10; ate = true;
      applesSinceKnight++;
      // Spawn Green Knight after 5-10 apples, if not already present
      if(!greenKnight && applesSinceKnight >= 12 + Math.floor(Math.random()*7)) {
        spawnGreenKnight();
        applesSinceKnight = 0;
      }
      spellFx.push({type:"eat", col:v.col, row:v.row, life:10});
      // Respawn
      villagers[i] = makeVillager(propList.avoid, new Set(snake.map(s=>`${s.col},${s.row}`)));
      break;
    }
  }
  if(!ate) snake.pop();

  tickVillagers();

  if(shroudTimer>0) shroudTimer--;
  slimeTiles = slimeTiles.filter(t => { t.life--; return t.life > 0; });
  spellFx = spellFx.filter(e=>{ e.life--; return e.life>0; });

  clearInterval(intervalId);
  intervalId = setInterval(tick, BASE_INTERVAL);

  // Slime trail: if slimeActive, stamp current snake positions as fresh slime
  if(slimeActive > 0) {
    slimeActive--;
    snake.forEach(seg => {
      // avoid duplicate tile at same cell
      if(!slimeTiles.find(t => t.col===seg.col && t.row===seg.row)) {
        slimeTiles.push({ col:seg.col, row:seg.row, life:19, maxLife:19 }); // ~3s at 155ms
      }
    });
  }
  // Villagers on slime get briefly frozen
  villagers.forEach(v => {
    if(slimeTiles.find(t => t.col===v.col && t.row===v.row)) {
      v.frozen = Math.max(v.frozen||0, 6); // freeze for ~1s
    }
  });
  updateHUD();
  draw();
}

// â”€â”€ SPELLS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function castSpell(idx) {
  if(gameOver) return;
  const sp = SPELLS[idx];
  if(snake.length - sp.cost < 3) { showEffect("âš  TOO SMALL TO CAST", 1200); return; }
  for(let i=0;i<sp.cost;i++) snake.pop();

  if(idx===0) {
    for(let i=1;i<=3;i++) {
      const bc=snake[0].col+dir.col*i, br=snake[0].row+dir.row*i;
      spellFx.push({type:"burst",col:bc,row:br,life:14});
      for(let vi=0;vi<villagers.length;vi++) {
        if(villagers[vi].col===bc&&villagers[vi].row===br) {
          score+=5;
          villagers[vi]=makeVillager(propList.avoid, new Set(snake.map(s=>`${s.col},${s.row}`)));
        }
      }
    }
    showEffect("ğŸ’¥ BONE BURST!", 1800);
  } else if(idx===1) {
    slimeActive = 20; // ~3 seconds at 155ms per tick
    showEffect("ğŸŸ¢ SLIME TRAIL!", 1800);
  } else if(idx===2) {
    shroudTimer=10;
    showEffect("ğŸŒ‘ DEATH SHROUD!", 1800);
  }
  updateHUD(); draw();
}

let effectTO;
function showEffect(msg, ms) {
  document.getElementById("effect-hud").textContent = msg;
  clearTimeout(effectTO);
  effectTO = setTimeout(()=>document.getElementById("effect-hud").textContent="", ms);
}

// â”€â”€ HUD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 
function updateHUD() {
  document.getElementById("score-hud").textContent  = score;
  document.getElementById("length-hud").textContent = snake.length;
  SPELLS.forEach((sp,i) => {
    const el = document.getElementById("slot-"+i);
    const ready = snake.length > sp.cost + 2;
    el.className = "spell-slot " + (ready ? "ready" : "not-ready");
    if(i===1&&slimeActive>0) el.classList.add("active");
    if(i===2&&shroudTimer>0) el.classList.add("active");
  });
}

// â”€â”€ DRAW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 
function draw() {
  ctx.clearRect(0,0,W,H);

  // Background
  if(IMG.bg) {
    ctx.drawImage(IMG.bg, 0, 0, W, H);
  } else {
    ctx.fillStyle="#151510"; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle="#1e1e16"; ctx.lineWidth=1;
    for(let c=0;c<COLS;c++) for(let r=0;r<ROWS;r++) ctx.strokeRect(c*CELL,r*CELL,CELL,CELL);
  }

  // Death shroud tint
  if(shroudTimer>0) {
    ctx.fillStyle=`rgba(20,0,50,${0.4*(shroudTimer/10)})`;
    ctx.fillRect(0,0,W,H);
  }

  // Props
  propList.list.forEach(p => {
    const x=p.col*CELL, y=p.row*CELL;
    if(IMG.props) {
      drawPropSprite(p.type, x, y);
    } else {
      ctx.fillStyle="#443322"; ctx.fillRect(x+2,y+2,CELL-4,CELL-4);
      ctx.fillStyle="#221108"; ctx.font="18px serif"; ctx.textAlign="center";
      ctx.fillText("ğŸ ",x+CELL/2,y+CELL/2+6);
    }
  });

  // Villagers
  villagers.forEach(v => {
    const x=v.col*CELL, y=v.row*CELL;
    if(IMG.villager) {
      drawVillagerSprite(v.frame, x, y);
    } else {
      // fallback: tiny figure
      ctx.fillStyle="#c8884b";
      ctx.fillRect(x+10,y+8,12,18);
      ctx.fillStyle="#f0c070";
      ctx.beginPath(); ctx.arc(x+16,y+6,5,0,Math.PI*2); ctx.fill();
    }
  });

  // Green Knight
  if(greenKnight) {
    const x = greenKnight.col*CELL, y = greenKnight.row*CELL;
    if(IMG.knight) {
      drawKnightSprite(greenKnight.frame, greenKnight.dir, x, y);
    } else {
      ctx.fillStyle="#22bb22";
      ctx.fillRect(x+8, y+4, CELL-16, CELL-8);
    }
  }

  // Green Knight announcement banner
  if(knightAnnounce > 0) {
    // fade in over first 10 frames, fade out over last 20 frames
    const fadeIn  = Math.min(1, (90 - knightAnnounce) / 10);
    const fadeOut = Math.min(1, knightAnnounce / 20);
    ctx.save();
    ctx.globalAlpha = Math.min(fadeIn, fadeOut);
    ctx.fillStyle = "rgba(10,40,10,0.82)";
    ctx.fillRect(W/2 - 240, H/2 - 36, 480, 64);
    ctx.strokeStyle = "#44ff44";
    ctx.lineWidth = 2;
    ctx.strokeRect(W/2 - 240, H/2 - 36, 480, 64);
    ctx.fillStyle = "#44ff44";
    ctx.font = "bold 22px 'Courier New', monospace";
    ctx.textAlign = "center";
    ctx.shadowColor = "#44ff44"; ctx.shadowBlur = 14;
    ctx.fillText("âš”  THE GREEN KNIGHT APPROACHES  âš”", W/2, H/2 + 8);
    ctx.restore();
  }

  // Spell FX
  // Draw slime tiles (render under spellFx, above background)
  slimeTiles.forEach(t => {
    const alpha = (t.life / t.maxLife) * 0.65; // fade from 65% to 0
    const x = t.col * CELL, y = t.row * CELL;
    ctx.save();
    ctx.globalAlpha = alpha;
    // Slime puddle: dark yellow-green blob
    ctx.fillStyle = '#5aaf1a';
    ctx.shadowColor = '#7fff00'; ctx.shadowBlur = 6;
    ctx.beginPath();
    ctx.ellipse(x + CELL*0.5, y + CELL*0.55, CELL*0.42, CELL*0.32, 0, 0, Math.PI*2);
    ctx.fill();
    // Inner highlight
    ctx.globalAlpha = alpha * 0.5;
    ctx.fillStyle = '#a8ff3e';
    ctx.shadowBlur = 0;
    ctx.beginPath();
    ctx.ellipse(x + CELL*0.45, y + CELL*0.48, CELL*0.18, CELL*0.12, -0.3, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  });

  spellFx.forEach(e => {
    const x=e.col*CELL, y=e.row*CELL;
    if(e.type==="burst") {
      const t=e.life/14;
      ctx.save();
      ctx.globalAlpha=t;
      ctx.shadowColor="#ff7020"; ctx.shadowBlur=20;
      ctx.fillStyle=`rgb(255,${Math.floor(80+120*t)},20)`;
      const r=(CELL/2)*t+6;
      ctx.beginPath(); ctx.arc(x+CELL/2,y+CELL/2,r,0,Math.PI*2); ctx.fill();
      ctx.restore();
    } else if(e.type==="eat") {
      ctx.save();
      ctx.globalAlpha=e.life/10;
      ctx.fillStyle="#c8a84b";
      ctx.font=`bold ${13+(10-e.life)}px 'Courier New'`;
      ctx.textAlign="center";
      ctx.shadowColor="#c8a84b"; ctx.shadowBlur=8;
      ctx.fillText("+10", x+CELL/2, y - (10-e.life)*2);
      ctx.restore();
    }
  });

  // Snake
  drawSnake();
}

function drawSnake() {
  const len = snake.length;
  snake.forEach((seg, i) => {
    const x=seg.col*CELL, y=seg.row*CELL;
    const alpha = shroudTimer>0 ? (0.4+0.6*Math.sin(Date.now()/60)) : 1;

    if(IMG.snake) {
      ctx.save();
      ctx.globalAlpha = alpha;
      if(i===0) {
        // Head: rotate to face direction
        // Sprite faces DOWN natively; subtract Ï€/2 to rotate CCW 90Â° â†’ faces RIGHT at angle=0
        const angle = Math.atan2(dir.row, dir.col) - Math.PI/2;
        drawSnakeSprite("head", x, y, angle);
      } else if(i===len-1) {
        // Tail: point away from body; +Ï€/2 offset mirrors head's -Ï€/2 (opposite correction)
        const prev = snake[i-1];
        const angle = Math.atan2(seg.row-prev.row, seg.col-prev.col) + Math.PI/2 + Math.PI;
        drawSnakeSprite("tail", x, y, angle);
      } else {
        // Body: detect corner vs straight
        const prev=snake[i-1], next=snake[i+1];
        const dx1=prev.col-seg.col, dy1=prev.row-seg.row;
        const dx2=next.col-seg.col, dy2=next.row-seg.row;
        const straight = (dx1===-dx2) || (dy1===-dy2);
        if(straight) {
          // Use head-side to tail-side travel angle; ribs need +Ï€/2 to stay perpendicular to travel
          const travelAngle = Math.atan2(prev.row - next.row, prev.col - next.col);
          drawSnakeSprite("body", x, y, travelAngle + Math.PI/2);
        } else {
          // Corner: use diagonal between the two incoming directions
          const travelAngle = Math.atan2(prev.row - next.row, prev.col - next.col);
          drawSnakeSprite("curve", x, y, travelAngle + Math.PI/4);
        }
      }
      ctx.restore();
    } else {
      // Procedural fallback
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = i===0 ? "#d0bc88" : (i%2===0?"#a8926a":"#907854");
      const p=i===0?2:3;
      ctx.fillRect(x+p,y+p,CELL-p*2,CELL-p*2);
      if(i===0) {
        ctx.fillStyle="#ff4400"; ctx.shadowColor="#ff4400"; ctx.shadowBlur=10;
        ctx.fillRect(x+CELL/2-7+dir.col*5, y+CELL/2-3+dir.row*5, 4,4);
        ctx.fillRect(x+CELL/2+3+dir.col*5, y+CELL/2-3+dir.row*5, 4,4);
        ctx.shadowBlur=0;
      }
      ctx.restore();
    }
  });
}

// â”€â”€ END GAME â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const DEATHS = [
  "THE GRAVE RECLAIMS ITS OWN",
  "SILENCE FALLS OVER THE RUINS",
  "THE WYRM CRUMBLES TO DUST",
  "ANOTHER SOUL FOR THE EARTH",
  "THE BONES RETURN TO DUST",
];
function endGame(reason) {
  gameOver = true;
  clearInterval(intervalId);
  draw();
  const ov = document.getElementById("overlay");
  ov.innerHTML = `
    <div id="game-over-msg">THE CRAWLER FALLS</div>
    <div id="death-flavor">${reason}</div>
    <div id="score-big">ğŸ’€ ${score}</div>
    <p>Length reached: ${snake.length} segments</p>
    <button id="start-btn" style="margin-top:32px">RISE AGAIN</button>
  `;
  ov.classList.remove("overlay-hidden");
  document.getElementById("start-btn").addEventListener("click", startGame);
}

// â”€â”€ INPUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 
const KEYS = {
  ArrowUp:{col:0,row:-1}, ArrowDown:{col:0,row:1},
  ArrowLeft:{col:-1,row:0}, ArrowRight:{col:1,row:0},
  w:{col:0,row:-1}, s:{col:0,row:1}, a:{col:-1,row:0}, d:{col:1,row:0},
  W:{col:0,row:-1}, S:{col:0,row:1}, A:{col:-1,row:0}, D:{col:1,row:0},
};
document.addEventListener("keydown", e => {
  if(KEYS[e.key]) {
    e.preventDefault();
    const nd=KEYS[e.key];
    if(nd.col !== -dir.col || nd.row !== -dir.row) nextDir = nd;
  }
  if(e.key==="1") { e.preventDefault(); castSpell(0); }
  if(e.key==="2") { e.preventDefault(); castSpell(1); }
  if(e.key==="3") { e.preventDefault(); castSpell(2); }
});

// â”€â”€ START â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 
function startGame() {
  document.getElementById("overlay").classList.add("overlay-hidden");
  initGame();
  clearInterval(intervalId);
  intervalId = setInterval(tick, BASE_INTERVAL);
  draw();
}

// â”€â”€ BOOT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 
Promise.all([
  loadImg("bg",      "assets/bg.jpg"),
  loadImg("snake",   "assets/snake.png"),
  loadImg("villager","assets/villager.png"),
  loadImg("props",   "assets/props.png"),
  loadImg("knight",  "assets/knight.png"),
]).then(() => {
  // Runtime magenta-kill: nuke any pixel where R > G+55 && B > G+55
  // Catches JPEG-compressed fringe that survives PNG alpha keying
  function killMagenta(imgEl) {
    if (!imgEl) return imgEl;
    const oc = document.createElement('canvas');
    oc.width = imgEl.naturalWidth; oc.height = imgEl.naturalHeight;
    const ox = oc.getContext('2d');
    ox.drawImage(imgEl, 0, 0);
    const id = ox.getImageData(0, 0, oc.width, oc.height);
    const d = id.data;
    for (let i = 0; i < d.length; i += 4) {
      const r = d[i], g = d[i+1], b = d[i+2];
      if (r - g > 55 && b - g > 55) { d[i+3] = 0; }
      else if (r - g > 25 && b - g > 25) {
        const s = Math.min((r-g-25)/30, (b-g-25)/30, 1);
        d[i+3] = Math.round(d[i+3] * (1 - s));
      }
    }
    ox.putImageData(id, 0, 0);
    return oc;
  }
  IMG.knight = killMagenta(IMG.knight);
  initGame(); draw();
  document.getElementById("start-btn").addEventListener("click", startGame);
}).catch(() => {
  initGame(); draw();
  document.getElementById("start-btn").addEventListener("click", startGame);
});
</script>
</body>
</html>
